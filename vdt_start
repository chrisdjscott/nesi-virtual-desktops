#!/bin/bash -e

# Command for starting 'virtual desktop'. A VNC server running inside a container with XFCE with pre-made config/cache.
# Author: Callum
# https://github.com/nesi/nesi-virtual-desktops


# TODO: Add filesystem shortcuts to desktop.

VDT_HOME=${VDT_HOME:-"$HOME/.vdt"}
VDT_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
VDT_LOCKFILES=${VDT_LOCKFILES:-"$VDT_ROOT/lockfiles"} 
VDT_TEMPLATES=${VDT_TEMPLATES:-"$VDT_ROOT/templates"}

max_desktops=3;

module purge > /dev/null  2>&1
module load Python Singularity/3.5.2 -q 
module unload XALT/NeSI -q

help() {
cat << EndOfHelp
[1mNAME[0m
        $(VDT_BASEname "$0") - Start a new virtual desktop

[1mSYNOPSIS[0m
        $(VDT_BASEname "$0") [-h -c -v -p -s] [-b template] [-r host] [-N name] [-t seconds] [-d port] <port>

[1mDESCRIPTION[0m
        Starts a VGL enabled virtual desktop.

[1mPARAMETERS[0m

    -h --help               This is help.

    -r --remote [host]      Start vdt on [host].

    -p --persistent         Container will be run as a service. (e.g. will stay alive after closing your terminal)

    -c --clean              Overwrite User desktop settings.

    -b --VDT_BASE [template]    Template (default=eng)

    -N --name [name]        Desktop name (default=VDT_BASE).

    -t --timeout [s]        Timeout server after [s] seconds.

    -s --secure             Connects though an encrypted websocket.

    -C --nohome             Don't mount home directory. Good for debugging.

    -v --verbose

EndOfHelp
}

parse_input() {
    args=( "$@" ) # Save unshifted args for later.
    
    while true;do
        case $1 in
            -v|--verbose)
                verbose="-v"
                #set -x
                shift
            ;;
            -c|--clean)
                clean="true"
                shift
            ;;
            -C|--nohome)
                nohome="-C"
                shift
            ;;
            -p|--persistent)
                echo "persistant containers currently disabled"
                #exit 1 
                persistent="&"
                shift
            ;;
            -r|--remote)
                remote="${2}"
                shift
                shift
            ;;
            -t|--timeout)
                timeout="timeout ${2}"
                shift
                shift
            ;;
            -b|--VDT_BASE)
                VDT_BASE="${2}"
                shift
                shift
            ;;
            -N|--name)
                _instance_name="${2}"
                shift
                shift
            ;;
            -d|--display)
                _display_port="${2}"
                #set -x
                shift
                shift
            ;;
            -s|--secure)
                secure="true"
                shift
            ;;
            -h|--help)
                help "$0"
                exit 0
                shift
            ;;
            *)  
                if [[ $# -eq 1 ]];then
                    if (($1 < 2));then
                        echo "Port number must be larger than 1.";exit 1
                    elif (($1 > 65535));then
                        echo "Port number must be less than 65536.";exit 1
                    else (($1 >= 1 && $1 <= 65535))
                        VDT_SOCKET_PORT="$1";break
                    fi
                fi
                if [[ $# -eq 0 ]];then
                    echo "You must include a valid port number. '$(basename "$0") -h' for help.";exit 1
                fi
                echo "$@"
                echo "Unknown option '${1}', '$(basename "$0") -h' for help."  >&2
                help "$0"
                exit 1
            ;;
        esac
    done
    if ls ${VDT_LOCKFILES}/*${remote:-$(hostname)}:${VDT_SOCKET_PORT} 1> /dev/null 2>&1;then echo "Socket port '${VDT_SOCKET_PORT}' is in use on ${remote:-$(hostname)}, please choose another.";return 1;fi    

    # Create directory for logs, certificates etc
    mkdir -p "${VDT_HOME:="${HOME}/.vdt"}"

    # Select template.
    if [[ -z "${VDT_BASE}" ]];then VDT_BASE="default";fi
    if (ls ${VDT_TEMPLATES}/${VDT_BASE} > /dev/null); then
        echo "Using '${VDT_BASE}' as template."
    else
        echo "Unknown template '${1}', valid options are '$(ls ${VDT_TEMPLATES})'.\n"
    fi

    # Create name.
    VDT_INSTANCE_NAME=${_instance_name:-"${VDT_BASE}_${USER}"}
     # Set logfiles dest
    vecho "${VDT_LOGFILE:="${VDT_HOME}/${VDT_INSTANCE_NAME}.${remote:-$(hostname)}:${VDT_SOCKET_PORT}.log"}"
    touch "${VDT_LOGFILE}"
    vecho "logfile is ${VDT_LOGFILE}"

    # If clean flag exists remove cache.
    while true; do
        if ! ls "${VDT_LOCKFILES}"/*"${VDT_INSTANCE_NAME}"* 1> /dev/null 2>&1;then echo "Instance name: ${VDT_INSTANCE_NAME}";break;fi
        export VDT_INSTANCE_NAME="${VDT_INSTANCE_NAME}_new";    
    done   

    # Get node from env if slurm id set.
    vecho "Destination is '${remote}', Current host '$(hostname)'"
    if [[ -n "$SLURM_JOB_ID" && -z "$remote" && "$(hostname)" != "$remote" ]]; then
        remote=$(echo $SLURM_NODELIST | sed -E 's/^([a-z]{3})\[+([0-9]{3}).*/\1\2/')
        echo "Connection will be forwarded to $remote. Run 'unset SLURM_JOB_ID' if this isn't what you want."
    fi
    # if [[ -z "$session_jobid" && -n "$SLURM_JOB_ID" ]]; then
    #     printf "'SLURM_JOB_ID' set. Connection will be forwarded to job $SLURM_JOB_ID.\n"
    #     export session_jobid="$SLURM_JOB_ID"
    # fi

    lockfile="${VDT_LOCKFILES}/${VDT_INSTANCE_NAME}.${remote:-$(hostname)}:${VDT_SOCKET_PORT}"
    vecho "Lockfile is ${lockfile}"

    #find "$VDT_LOCKFILES" -type f -user "$(whoami)" -name *${1}* -exec rm ${verbose} -f {} \;
}

ssh_forward(){
    # If remote destination is set, and not self.
    if [[ -n $remote ]] && [[ ! $remote == $(hostname) ]];then
        echo "Forwarding to ${remote}..."

        # If ephemeral, local forwarding is good. 
        if [[ -z $persistent ]];then
            localforward="-L ${VDT_SOCKET_PORT}:localhost:${VDT_SOCKET_PORT}"
        else
            export VDT_TUNNEL_HOST="$(hostname)"
            env_fwd="export VDT_TUNNEL_HOST=$(hostname) && "
        fi
        vex ssh ${verbose} -A -o ExitOnForwardFailure=yes ${localforward} "${remote}" "${env_fwd}${VDT_ROOT}/vdt_start" "${args[@]:0}"
        # Take original arguments
        exit $?
    fi
  
}
set_env(){
    if [[ -n $clean ]];then
        "${VDT_ROOT}/clean_env"
    fi
    if [[ -n $secure ]];then
        # If environment setup for desktop flavor.
        echo "Generating security certificate."
        if [[ ! -f "${VDT_HOME}/self.pem" ]];then
            openssl req -new -x509 -days 365 -nodes -subj "/C=NZ/ST=Wellington/L=Wellington/O=NeSI/CN=$(hostname)" -out "${VDT_HOME}/self.pem" -keyout "${VDT_HOME}/self.pem"
        fi    
        VDT_WEBSOCKOPTS="$VDT_WEBSOCKOPTS --cert=${VDT_HOME}/self.pem"
    fi

    set_display "$_display_port"

    export SINGULARITY_BINDPATH="\
/run,\
/etc/machine-id,\
/opt/nesi,\
/nesi/project,\
/nesi/nobackup,\
/usr/share/lmod/lmod,\
/etc/opt/slurm,\
/opt/slurm,\
/usr/lib64/libmunge.so,\
/usr/lib64/libmunge.so.2,\
/usr/lib64/libmunge.so.2.0.0"

    vecho "Singularity bindpath is $(echo "${SINGULARITY_BINDPATH}" | tr , '\n')"

    
    # If environment setup for desktop flavor.
    if [[ -f "${VDT_TEMPLATES}/${VDT_BASE}/pre.sh" ]];then
        source "${VDT_TEMPLATES}/${VDT_BASE}/pre.sh" 
    fi

    # Export all variables starting with 'VDT' to singularity.
    for ev in $(compgen -A variable | grep ^VDT );do
        export "SINGULARITYENV_$ev"="${!ev}"
        vecho "SINGULARITYENV_$ev=${!ev}"
    done
    
    # Murder any ports that were missed.
    while [[ "$(fuser "$VDT_SOCKET_PORT"/tcp 2>/dev/null | wc -w)" -gt 0 ]];do
        echo "Port '$VDT_SOCKET_PORT' in use. Killing $VDT_SOCKET_PORT"
        kill -9 $(fuser "$VDT_SOCKET_PORT"/tcp 2>/dev/null | awk '{ print $1 }')
    done
}

create_vnc(){   
    # Set instance name
    if [[ ! -x  "$(readlink -f "$VDT_TEMPLATES/$VDT_BASE/image")" ]];then echo "'$VDT_TEMPLATES/$VDT_BASE/image' doesn't exist!";exit 1;fi

    img_path=$(readlink -f "$VDT_TEMPLATES/$VDT_BASE/image")
    touch "${lockfile}"
    if [[ -n $persistent ]];then
        vex "${timeout}" singularity "${verbose}" instance start "${nohome}" "${img_path}" "${VDT_INSTANCE_NAME}" 
        img_path="instance://${VDT_INSTANCE_NAME}"
        sleep 3
        printf "Desktop %s started\n" "${VDT_INSTANCE_NAME}"
        printf "Connect at: http://localhost:%s  \nKill with: vdt kill %s" "${VDT_SOCKET_PORT}" "${VDT_INSTANCE_NAME}"
    else
        vex "${timeout}" singularity "${verbose}" run "${nohome}" "${img_path}"
    fi
}

set_display (){
    #Finds a free display port. If passed an argument, will test that then return.
    max_i=4;
    for (( i=0; i<max_i; i++ )); do
        VDT_DISPLAY_PORT=${1:-$(shuf -i 1100-2000 -n 1)}
        if [[ ! -e "/tmp/.X11-unix/X{$VDT_DISPLAY_PORT}" ]];then return 0;fi
        if [[ $# -gt 0 ]];then echo "Selected display port ${1} not suitable."; return 2;fi
    done
    echo "Could not find a suitable display port after $max_i attempts."; return 1
}

vecho () {
    # For verbose print.
    if [[ $verbose ]]; then
        echo "$LINENO:$*"
    fi
    echo "$LINENO:$*" >> "$VDT_LOGFILE"
}

vex () {
    # For verbose execute.
    if [[ $verbose ]]; then
        echo "$LINENO:$*"
    fi
    echo "$LINENO:$*" >> "$VDT_LOGFILE"
    $@
}

main() {
    parse_input "$@"
    ssh_forward 
    set_env
    create_vnc
    
    return 0
}
cleanup() {
    #vncserver
    singularity $verbose exec "$img_path" "vncserver -kill ":$VDT_DISPLAY_PORT"" 1> ${VDT_LOGFILE} 2>&1 || true
    rm -f $verbose /tmp/.X11-unix/.X*
    rm -f $verbose "$HOME"/.vnc/*"${VDT_INSTANCE_NAME}".pid
    if [[ -n "${VDT_LOGFILE}" ]]; then rm -f $verbose "${VDT_LOGFILE}";fi
    if [[ -n "${lockfile}" ]]; then rm -f $verbose "${lockfile}";fi
    pkill --signal 9 -P $$ > /dev/null 2>&1 
    #rm -f "/tmp/.X$display_port-lock"
    return 0
    # while [[ "$(fuser $1/tcp 2>/dev/null | wc -w)" -gt 0 ]];do
    #     kill -9 "$(fuser $1/tcp 2>/dev/null | awk '{ print $1 }')"
    # done
}
# construct_ssh() {
#     # If jobid is specified, get host of jobid.
#     if [[ "$session_jobid" ]];then
#         while true;do
#             sqout=$(squeue -h -u "$USER" -j "$session_jobid" -O "State,NodeList")
#             vecho $sqout
#             jobstate=$(echo $sqout | awk '{print $1}')
#             echo $jobstate
#             session_hostname=$(echo $sqout | awk '{print $2}')
#             if [[ $jobstate == "RUNNING" ]]; then
#                 iprint "Connection will be forwarded to $session_hostname\n"
#                 break
#                 elif [[ $jobstate == "PENDING" ]]; then
#                 iprint "'$session_jobid' is pending. Waiting..."
#                 sleep 10
#             else
#                 iprint "'$session_jobid' is not a valid slurm session to connect to.\n"
#                 unset session_jobid session_hostname
#                 exit 1
#             fi
#         done
#     fi
    
#     # Case 0 - Already on correct node.
#     if [[ "$session_hostname" = "$HOSTNAME" ]];then
#         "$@"
#         # Case 1 - No node specified. (Do nothing)
#         elif [[ ! "$session_jobid" ]] && [[ ! "$session_hostname" ]];then
#         "$@"
#         # Case 2 - Node specified, forwarding port specified. (Forward port to node)
#         elif [[ "$INBOUND_PORT" ]]; then
#             ssh -L "${INBOUND_PORT}:localhost:${INBOUND_PORT}" "${session_hostname}" "$@"
#         # Case 3 - Node specified, forwarding port not specified. (Run command on node)
#         elif [[ ! "$INBOUND_PORT" ]]; then
#             ssh "${session_hostname}" "$@"
#     else
#         echo "Something went wrong, couldn't construct SSH tunnel"
#         return 1
#     fi
# }
trap cleanup INT

main "$@"

