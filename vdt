#!/bin/bash -e

# Provides simple inteface for setting up VNC sessions, connecting, hosting noVNC etc etc.
# Author: Callum
# https://github.com/nesi/nesi-virtual-desktops


# TODO: Add filesystem shortcuts to desktop.
module purge > /dev/null  2>&1
module load Python Singularity/3.6.1 -q 
module unload XALT/NeSI -q

unset LD_PRELOAD

#Location of this script
ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
#ROOT="$( dirname "${0}")"

xdg_root="${HOME}/.nesi_vdt"
vnc_pid_root="${HOME}/.vnc"

# export XDG_CONFIG_HOME="$xdg_root/.config/"
# export XDG_CACHE_HOME="$xdg_root/.cache/"

SIF_DIR="$(dirname $ROOT)/containers/images"

#TEMP_HOME="$(dirname $(dirname $(realpath $0)))/dt_config/eng"

# Where files are saved in user home.

cleanup_graceful() {
    # Run this when dying.
    # singularity exec instance://$EPHEMERAL_INSTANCE_NAME vncserver -kill :${display_port}
    # singularity instance stop $EPHEMERAL_INSTANCE_NAME #> /dev/null 2>&1
    #iprint "${VARIABLE:=default} active desktops will persist in "
    if [[ $NUM_INST -gt 0 ]]; then
        printf "$NUM_INST desktops will persist in the background. Run '$(basename $0)' again to manage connections.\n"
    fi
    exit 0
}

help() {
cat << EndOfHelp
[1m$CWD[0m

[1mSYNOPSIS[0m
        $CWD [-h -P -n -v] [-j jobid] [port]

[1mDESCRIPTION[0m
        Starts a VGL enabled virtual desktop and sets up noVNC server.

[1mPARAMETERS[0m

    -h --help               This is help.

    -s --socketless           Start the virtual desktop without the websocket.

    -c --clean              Overwrite User desktop settings.

    -C --nohome             Don't mount home directory. Good for debugging.

    -j --jobid [jobid]      Forward connection to host of [jobid]

    -n --node [hostname]    Forward connection to [hostname]

    -v --verbose

EndOfHelp
}

parse_input() {
    
    vecho "$@"
    # Command line input before being shifted
    args=( "$@" )
    
    # If desktop named. Use. Else default.
    DESKTOP="eng"
    
    # Parse flags + port
    while [[ $# -gt 0 ]];do
        case "$1" in
            -v|--verbose)
                export VERBOSE="-v"
                export v="-v"
                #set -x
                shift
            ;;
            -p|--persistent)
                export PERSISTENT="true"
                echo "Currently '-p' does nothing. All instances are persistant."
                shift
            ;;
            -s|--socketless)
                export NOSOCKET="true"
                shift
            ;;
            -c|--clean)
                clean="--clean"
                shift
            ;;
            -h|--help)
                help $0
                exit 0
            ;;
            -C|--nohome)
                nohome="--nohome"
                shift
            ;;
            -j|--jobid)
                export session_jobid="$2"
                shift
                shift
            ;;
            -n|--node)
                export session_hostname="$2"
                shift
                shift
            ;;
            [0-9]*)
                export INBOUND_PORT=$1
                shift
            ;;
            *)
                if (ls ${ROOT}/${1} > /dev/null); then
                    DESKTOP=$1
                    shift
                else
                    iprint "Unknown option '${1}', -h for help.\n"
                    shift
                fi
            ;;
        esac
    done
    
    # Get 'environmental inputs'.
    # If no jobid specified, but launched from env with SLURM env set. Go there.
    if [[ -z "$session_jobid" && -n "$SLURM_JOB_ID" ]]; then
        printf "'SLURM_JOB_ID' set. Connection will be forwarded to job $SLURM_JOB_ID.\n"
        export session_jobid="$SLURM_JOB_ID"
    fi
}
# Construct ssh command.
construct_ssh() {
    # If jobid is specified, get host of jobid.
    if [[ "$session_jobid" ]];then
        while true;do
            sqout=$(squeue -h -u "$USER" -j "$session_jobid" -O "State,NodeList")
            vecho $sqout
            jobstate=$(echo $sqout | awk '{print $1}')
            echo $jobstate
            session_hostname=$(echo $sqout | awk '{print $2}')
            if [[ $jobstate == "RUNNING" ]]; then
                iprint "Connection will be forwarded to $session_hostname\n"
                break
                elif [[ $jobstate == "PENDING" ]]; then
                iprint "'$session_jobid' is pending. Waiting..."
                sleep 10
            else
                iprint "'$session_jobid' is not a valid slurm session to connect to.\n"
                unset session_jobid session_hostname
                exit 1
            fi
        done
    fi
    
    # Case 0 - Already on correct node.
    if [[ "$session_hostname" = "$HOSTNAME" ]];then
        "$@"
        # Case 1 - No node specified. (Do nothing)
        elif [[ ! "$session_jobid" ]] && [[ ! "$session_hostname" ]];then
        "$@"
        # Case 2 - Node specified, forwarding port specified. (Forward port to node)
        elif [[ "$INBOUND_PORT" ]]; then
            ssh -L "${INBOUND_PORT}:localhost:${INBOUND_PORT}" "${session_hostname}" "$@"
        # Case 3 - Node specified, forwarding port not specified. (Run command on node)
        elif [[ ! "$INBOUND_PORT" ]]; then
            ssh "${session_hostname}" "$@"
    else
        echo "Something went wrong, couldn't construct SSH tunnel"
        return 1
    fi
}

create_vnc(){
    vecho "This script is in $ROOT"
    vecho "Bind path: $SINGULARITY_BINDPATH"
    vecho "Available SIFs $(ls $SIF_DIR)"
    
    display_port=$(shuf -i 1100-2000 -n 1)
    #SOCKET_PORT=$((5900))
    SELECTED_INST="${DESKTOP}_${SOCKET_PORT}"
    
    
    # Set instance name
    # If given persist name. Won't be killed on exit.
    
    # This way the same singularity container is always used.
    # vecho $((singularity ${v} instance start --cleanenv "$(readlink -f "$ROOT/$DESKTOP/image")" $INSTANCE_NAME) 2>&1)
    # singularity ${v} exec instance://${INSTANCE_NAME} vncserver -wm startxfce4 -geometry 1920x1080 -securitytypes TLSNone,X509None,None ":${display_port}"
    iprint "Creating new session... ($display_port)";
    #Randomy generate port number. Add lockfiles later.
    construct_ssh "${ROOT}/start_vdt" $v $clean $nohome $display_port
    
    if [[ $NOSOCKET ]]; then
        iprint "Websocket will not be created. Connect to this desktop using the $(basename $0) command, or using a VNC client to connect to http://localhost:$SOCKET_PORT (through a forwarded port).\n"
    fi
}

slurm_adopt(){
    OPT_COUNT_SQUEUE="0"
    menu_text="${MENU_HEAD}\nSelect a job\?\n"
    sq_menu_text=( $(squeue -h -u $USER -O "Jobid,Name,State,NodeList" | tr -s ' ' '|' | tr -s '\n' ' ' ) )
    #echo "${sq_menu_text[1]}"
    #echo "${#sq_menu_text[@]}"
    for sq in "${sq_menu_text[@]}"; do
        #$(echo $x | awk '{print $2}')
        menu_text="$menu_text\n\t${OPT_COUNT_SQUEUE}) $(echo ${sq} | awk -F "|" '{print $1 " (" $2 ") - " $3}')"
        ADOPT_VALID="$ADOPT_VALID $OPT_COUNT_SQUEUE"
        OPT_COUNT_SQUEUE=$((OPT_COUNT_SQUEUE + 1))
    done
    #echo "$OPT_COUNT_SQUEUE"
    
    if [[ $OPT_COUNT_SQUEUE -lt 1 ]]; then
        iprint "You don't have any running slurm jobs."
        return
    fi
    
    menu_text="$menu_text\n\tq)\n"
    mprint "$menu_text"
    # if [[ ${INBOUND_PORT} ]];then
    #     iprint "You must set a port before \n\tq)"
    #     return
    # fi
    
    while true; do
        PROMPT="[q$(echo "$ADOPT_VALID" | tr " " /)]"
        read -e -p "$PROMPT: " reply
        case $reply in
            ["${ADOPT_VALID[@]}"])
                session_jobid="$(echo "${sq_menu_text[$reply]}" | awk -F "|" '{print $1}')"
                session_hostname="$(echo "${sq_menu_text[$reply]}" | awk -F "|" '{print $4}')"
                echo $session_hostname
                return
            ;;
            q)                      return;;
            * )                     iprint "Please answer $PROMPT\r";;
        esac
    done
}

quit(){
    exit 0
}

kill_vnc(){
    # Get appropriate display number     
    vecho "Selected Instance: $session"  
    construct_ssh "${ROOT}/kill_vdt" "${session_display_port}" && NUM_INST=$((NUM_INST-1))
    #display_port=$(echo $SELECTED_SOCKET | awk -F[:,] '{print $2}')
    #singularity instance stop $INSTANCE_NAME
    #singularity exec instance://$INSTANCE_NAME vncserver -kill :${display_port}
}

connect_vnc(){
    vecho "Selected instance: ${session}"
    
    test_port "${INBOUND_PORT}"
    construct_ssh "${ROOT}/connect_vdt" ${VERBOSE} "${session_display_port}" "${INBOUND_PORT}"
}

menu(){
    while true; do
        # Genrate Menu Header
        menu_text="\nTemplate:      ${DESKTOP}\nDestination:   ${session_hostname:-${session_jobid:-"none. (Next desktop will be started on the login node)"}}"
        menu_text="${menu_text}\nInbound Port:  ${INBOUND_PORT:-"false. (Connect with VNC or run this command again with a port number)."}"
        menu_text="${menu_text}\nWARNING: To avoid bugs, only run 1 desktop at a time"
 
        # Get list of open VNC sessions. 
        vnc_list=( $(ls "${vnc_pid_root}"/*.pid 2> /dev/null || true) )
        vecho "${vnc_list[@]}"
        #INST_LIST=( $(singularity instance list | tail -n +2 | awk '{print $1}' ) )

        opt_count="0"

        # Print options for connecting to desktops.
        for session in "${vnc_list[@]}" ; do
            _display_port=$(echo "${session}" | sed -e 's/.*:\([0-9]*\).pid/\1/')
            _hostname=$(echo "$session" | sed -e 's/.*\/\(.*\):.*/\1/')
            
            menu_text="${menu_text}\n\n     Desktop: ${DESKTOP}"
            if [[ $(session_hostname=${_hostname};construct_ssh singularity instance list "*${_display_port}" | wc -l)  -lt 2 ]]; then
                menu_text="${menu_text}  (DEAD!)"
            fi
            menu_text="$menu_text\n     Host:    ${_hostname}:${_display_port}"
            menu_text="${menu_text}\n\t${opt_count}) Connect."
            opt_count=$((opt_count + 1))
            menu_text="${menu_text}\n\t${opt_count}) Kill."
            opt_count=$((opt_count + 1))
        done

       
        # Print the damn thing.
        mprint "${menu_text}\n\n\tn) New desktop.\n\ta) Adopt a SLURM session.\n\tq) Quit\n\nWhat would you like to do\?\n"
        # Main menu loop. Using functions for tidyness.
        
        PROMPT="[$(seq 0 $((opt_count - 1)) | tr "\n" /)n/a/q]"
        read -e -p "$PROMPT: " reply

        opt_count_m1=$((opt_count - 1))
        case $reply in
                n)                      create_vnc;&    #;& # Fallthough.
                [0-$opt_count_m1])      session="${vnc_list[$((reply / 2))]}"
                                        session_display_port=${display_port:-$(echo "${session}" | sed -e 's/.*:\([0-9]*\).pid/\1/')}
                                        session_hostname=$(echo "$session" | sed -e 's/.*\/\(.*\):.*/\1/')
                                        if [ $((reply%2)) -eq 0 ];then 
                                            connect_vnc
                                        else
                                            kill_vnc
                                        fi;; 
                a)                      slurm_adopt;;
                q)                      quit;;
                * )                     iprint "Please answer ";;
        esac
    done
    
}

vecho () {
    # For verbose print.
    if [[ $VERBOSE ]]; then
        echo "$@"
    fi
}

iprint () {
    # Inline print
    printf "\033[K\033[B$2$1"
}

mprint () {
    # Menu Print
    #printf "$1"
    printf "\e[2$(( 8+OPT_COUNT ))[\r$1\n\e[K"
}

test_port () {
    
    if [[ ! $INBOUND_PORT ]];then
        iprint "Missing a forwarding port. Please enter one now."
        PROMPT="[port]: "
        read -r -e -p "$PROMPT" INBOUND_PORT
    fi
    
    # Tests if port is available. If not KILLS IT. Might need consideration.
    vecho "|$INBOUND_PORT|"
    
    while [[ "$(fuser "$INBOUND_PORT"/tcp 2>/dev/null | wc -w)" -gt 0 ]];do
        #iprint "Port $1 in use. Please find another."
        iprint "Port '$INBOUND_PORT' in use. Killing $INBOUND_PORT"
        # Kill
        kill -9 $(fuser "$INBOUND_PORT"/tcp 2>/dev/null | awk '{ print $1 }')
    done
    # Too much kill
    # kill -9 $(ps -o ppid= $(fuser $INBOUND_PORT/tcp 2>/dev/null | awk '{ print $1 }'))
}

main() {
    parse_input "$@"
    menu
}

trap "cleanup_graceful" EXIT
main "$@"

